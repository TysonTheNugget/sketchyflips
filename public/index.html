<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sketchy Flips - Arcade Playground</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
        }
        body {
            background-image: url('/background.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            flex-direction: column;
        }
        @media (max-width: 768px) {
            html, body {
                overflow-y: auto;
            }
        }
        .neon-button {
            background: linear-gradient(to right, #ffeb3b, #ff9800);
            color: black;
            font-weight: bold;
            border-radius: 1.5rem;
            padding: 0.5rem 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .neon-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 8px rgba(255, 152, 0, 0.5), 0 0 20px rgba(255, 235, 59, 0.3);
        }
        .game-card {
            background: white;
            border-radius: 1rem;
            border: 2px solid #ff9800;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        .game-card:hover {
            transform: translateY(-5px);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 50;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 15px;
            width: 90%;
            max-width: 500px;
            border-radius: 1rem;
            border: 2px solid #ff9800;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 24px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .nft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.75rem;
        }
        .nft-item {
            cursor: pointer;
            text-align: center;
            transition: transform 0.3s ease;
        }
        .nft-item:hover {
            transform: scale(1.05);
        }
        .nft-item img {
            width: 100%;
            height: auto;
            border-radius: 0.75rem;
            border: 2px solid #ff9800;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #videoOverlay {
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        #videoOverlay.fade-in {
            opacity: 1;
        }
        #videoOverlay.fade-out {
            opacity: 0;
        }
        .info-button {
            background-color: #ff9800;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            width: 1.25rem;
            height: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .info-button:hover {
            transform: scale(1.1);
        }
        .status-pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body class="text-black">
    <!-- Header -->
    <header class="w-full text-center py-4 bg-gradient-to-r from-yellow-400 to-orange-500 shadow-md">
        <h1 class="text-2xl md:text-3xl font-extrabold text-white">üéÆ Sketchy Flips Arcade üé≤</h1>
        <p class="text-sm md:text-base text-white">Fun, friends, and flipping NFTs!</p>
    </header>

    <!-- Main Menu -->
    <div id="mainMenu" class="w-full max-w-3xl p-4 flex flex-col items-center justify-center flex-grow">
        <div class="flex flex-col sm:flex-row justify-center gap-4">
            <div class="relative">
                <button id="betButton" class="neon-button text-lg">Bet-A-Sketchy</button>
                <button id="infoButton" class="info-button absolute -top-2 -right-2">i</button>
            </div>
            <button class="neon-button text-lg opacity-50 cursor-not-allowed">Stake-A-Milio (Coming Soon)</button>
        </div>
    </div>

    <!-- Game Interface -->
    <div id="gameInterface" class="hidden w-full max-w-5xl p-4 flex flex-col md:flex-row gap-4 flex-grow">
        <!-- Left: Controls -->
        <div class="w-full md:w-1/2 flex flex-col gap-3 h-[calc(100vh-120px)] overflow-y-auto">
            <button id="connectWallet" class="neon-button text-sm">üîå Connect Wallet</button>
            <p id="accountInfo" class="game-card p-2 text-center text-xs">Account: Not connected</p>
            <div class="game-card p-3">
                <label class="block font-bold text-sm mb-1">Selected NFT:</label>
                <div id="selectedNFT" class="w-full p-2 rounded-lg border-2 border-orange-500 bg-white text-center text-sm">None selected</div>
                <button id="selectNFTBtn" disabled class="neon-button w-full mt-2 text-sm">üé® Select NFT</button>
            </div>
            <button id="createGameBtn" disabled class="neon-button w-full text-sm">üé∞ Create Flip Game</button>
            <div class="game-card p-3 flex-grow">
                <h2 class="text-lg text-center mb-2 font-bold">üéØ Open Games</h2>
                <ul id="openGamesList" class="space-y-3 max-h-40 overflow-y-auto"></ul>
            </div>
            <div class="game-card p-3 flex-grow">
                <h2 class="text-lg text-center mb-2 font-bold">‚è≥ My Ongoing Games</h2>
                <ul id="ongoingGamesList" class="space-y-3 max-h-40 overflow-y-auto"></ul>
            </div>
            <div class="game-card p-3 flex-grow">
                <h2 class="text-lg text-center mb-2 font-bold">üï∞ Timed Out Pending Games</h2>
                <ul id="timedOutGamesList" class="space-y-3 max-h-40 overflow-y-auto"></ul>
            </div>
            <div class="game-card p-3 text-center text-sm font-bold status-pulse">Status: <span id="status">Waiting for connection...</span></div>
        </div>

        <!-- Right: Character Image/Video Placeholder -->
        <div class="w-full md:w-1/2 flex items-center justify-center">
            <img id="characterImage" src="/static.jpg" alt="Standing Character" class="max-w-full max-h-80 rounded-xl shadow-lg border-2 border-orange-500">
        </div>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close">√ó</span>
            <h2 class="text-xl text-center mb-3 font-bold">About Bet-A-Sketchy</h2>
            <p class="text-center text-sm">50% chance PVP to win a Sketchy by betting one, verified by Gelato. 
                <a href="https://abscan.org/address/0xf6b8d2E0d36669Ed82059713BDc6ACfABe11Fde6#code" target="_blank" class="text-blue-500 hover:underline">View on ABScan</a> | 
                <a href="/moreinfo.html" target="_blank" class="text-blue-500 hover:underline">More Info</a>
            </p>
        </div>
    </div>

    <!-- NFT Selection Modal -->
    <div id="nftModal" class="modal">
        <div class="modal-content">
            <span class="close">√ó</span>
            <h2 class="text-xl text-center mb-3 font-bold">Select Your Sketchy NFT</h2>
            <div id="nftGrid" class="nft-grid"></div>
        </div>
    </div>

    <!-- Video Overlay -->
    <div id="videoOverlay" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 hidden">
        <div class="relative">
            <video id="resultVideo" class="max-w-full max-h-80 rounded-xl border-2 border-orange-500" autoplay></video>
            <div id="resultText" class="absolute inset-0 flex items-center justify-center text-white text-4xl font-bold" style="text-shadow: 2px 2px 4px black;"></div>
        </div>
    </div>

    <script>
        let provider, signer, account, gameContract, gameContractWithSigner, nftContract;
        const gameAddress = '0xf6b8d2E0d36669Ed82059713BDc6ACfABe11Fde6';
        const nftAddress = '0x08533a2b16e3db03eebd5b23210122f97dfcb97d';

        const gameABI = [
            "function createGame(uint256 tokenId)",
            "function joinGame(uint256 gameId, uint256 tokenId)",
            "function getOpenGames() view returns (uint256[])",
            "function getGame(uint256 gameId) view returns (tuple(address player1, uint256 tokenId1, address player2, uint256 tokenId2, bool active, uint256 requestId, bytes data, uint256 joinTimestamp, uint256 createTimestamp))",
            "function cancelGame(uint256 gameId)",
            "function cancelUnjoinedGame(uint256 gameId)",
            "function games(uint256) view returns (tuple(address player1, uint256 tokenId1, address player2, uint256 tokenId2, bool active, uint256 requestId, bytes data, uint256 joinTimestamp, uint256 createTimestamp))",
            "event GameCreated(uint256 gameId, address player1, uint256 tokenId1)",
            "event GameJoined(uint256 gameId, address player2, uint256 tokenId2)",
            "event RandomnessRequested(uint256 gameId, uint256 requestId)",
            "event GameResolved(uint256 gameId, address winner, uint256 tokenId1, uint256 tokenId2)",
            "event GameCanceled(uint256 gameId)"
        ];

        const nftABI = [
            "function tokensOfOwner(address owner) view returns (uint256[])",
            "function approve(address to, uint256 tokenId)",
            "function tokenURI(uint256 tokenId) view returns (string)"
        ];

        let refreshInterval;
        let selectedTokenId = null;
        let userTokens = [];

        // Modals
        const infoModal = document.getElementById('infoModal');
        const nftModal = document.getElementById('nftModal');
        const infoClose = infoModal.querySelector('.close');
        const nftClose = nftModal.querySelector('.close');
        const nftGrid = document.getElementById('nftGrid');
        const selectNFTBtn = document.getElementById('selectNFTBtn');

        infoClose.onclick = () => { infoModal.style.display = 'none'; };
        nftClose.onclick = () => { nftModal.style.display = 'none'; };
        window.onclick = (event) => {
            if (event.target == infoModal) infoModal.style.display = 'none';
            if (event.target == nftModal) nftModal.style.display = 'none';
        };

        document.getElementById('infoButton').addEventListener('click', () => {
            infoModal.style.display = 'block';
        });

        document.getElementById('betButton').addEventListener('click', () => {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('gameInterface').classList.remove('hidden');
        });

        selectNFTBtn.addEventListener('click', () => {
            displayNFTsInModal();
            nftModal.style.display = 'block';
        });

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        async function fetchUserTokens() {
            if (!nftContract || !account) return;
            userTokens = [];
            nftGrid.innerHTML = '<p class="text-center text-sm">Loading NFTs...</p>';
            try {
                const tokens = await nftContract.tokensOfOwner(account);
                for (let id of tokens) {
                    let uri = await nftContract.tokenURI(id);
                    if (uri.startsWith('ipfs://')) uri = 'https://ipfs.io/ipfs/' + uri.slice(7);
                    const response = await fetch(uri);
                    const metadata = await response.json();
                    let image = metadata.image;
                    if (image.startsWith('ipfs://')) image = 'https://ipfs.io/ipfs/' + image.slice(7);
                    userTokens.push({ id: id.toString(), image });
                }
                selectNFTBtn.disabled = userTokens.length === 0;
                document.getElementById('createGameBtn').disabled = userTokens.length === 0;
                if (userTokens.length === 0) {
                    nftGrid.innerHTML = '<p class="text-center text-sm">No NFTs owned</p>';
                }
            } catch (error) {
                updateStatus(`Tokens fetch error: ${error.message}`);
                nftGrid.innerHTML = '<p class="text-center text-red-500 text-sm">Error loading NFTs</p>';
            }
        }

        function displayNFTsInModal() {
            nftGrid.innerHTML = '';
            userTokens.forEach(token => {
                const div = document.createElement('div');
                div.className = 'nft-item';
                div.innerHTML = `<img src="${token.image}" alt="NFT #${token.id}" class="w-20 h-20"><p class="text-sm">#${token.id}</p>`;
                div.onclick = () => selectNFT(token.id, token.image);
                nftGrid.appendChild(div);
            });
        }

        function selectNFT(tokenId, image) {
            selectedTokenId = tokenId;
            document.getElementById('selectedNFT').innerHTML = `<img src="${image}" alt="NFT #${tokenId}" class="w-12 h-12 inline-block mr-2 rounded-lg">NFT #${tokenId}`;
            nftModal.style.display = 'none';
        }

        async function fetchOpenGames() {
            if (!gameContract || !account) return;
            const openGamesList = document.getElementById('openGamesList');
            try {
                const openIds = await gameContract.getOpenGames();
                if (openIds.length === 0) {
                    openGamesList.innerHTML = '<li class="text-center text-sm opacity-70">No open games. Create one!</li>';
                    return;
                }
                let listHTML = '';
                const currentTime = Math.floor(Date.now() / 1000);
                for (let id of openIds) {
                    const game = await gameContract.getGame(id);
                    let uri = await nftContract.tokenURI(game.tokenId1);
                    if (uri.startsWith('ipfs://')) uri = 'https://ipfs.io/ipfs/' + uri.slice(7);
                    const response = await fetch(uri);
                    const metadata = await response.json();
                    let image = metadata.image;
                    if (image.startsWith('ipfs://')) image = 'https://ipfs.io/ipfs/' + image.slice(7);
                    const createdAt = new Date(Number(game.createTimestamp) * 1000).toLocaleTimeString();
                    const isMine = game.player1.toLowerCase() === account.toLowerCase();
                    const canCancel = isMine && currentTime > Number(game.createTimestamp) + 3600;
                    let actionButton = '';
                    if (canCancel) {
                        actionButton = `<button class="neon-button py-1 px-2 text-xs" onclick="cancelUnjoinedFromList(${id})">Cancel</button>`;
                    } else if (isMine) {
                        actionButton = `<span class="text-xs opacity-70">Your game - Waiting for join</span>`;
                    } else {
                        actionButton = `<button class="neon-button py-1 px-2 text-xs" onclick="joinGameFromList(${id})">Join</button>`;
                    }
                    listHTML += `
                        <li class="game-card p-3 flex justify-between items-center">
                            <div class="flex items-center">
                                <img src="${image}" alt="NFT #${game.tokenId1}" class="w-10 h-10 mr-3 rounded-lg shadow">
                                <div>
                                    <span class="font-bold text-sm">Game #${id}</span><br>
                                    <span class="text-xs opacity-70">Bet: NFT #${game.tokenId1} | ${createdAt}</span>
                                </div>
                            </div>
                            ${actionButton}
                        </li>`;
                }
                openGamesList.innerHTML = listHTML;
            } catch (error) {
                updateStatus(`Error fetching open games: ${error.message}`);
                openGamesList.innerHTML = '<li class="text-center text-red-500 text-sm">Error loading games</li>';
            }
        }

        async function fetchOngoingGames() {
            if (!gameContract || !account) return;
            const ongoingGamesList = document.getElementById('ongoingGamesList');
            let listHTML = '';
            const currentTime = Math.floor(Date.now() / 1000);
            let foundAny = false;
            try {
                for (let i = 0; i < 1000; i++) {
                    try {
                        const game = await gameContract.getGame(i);
                        if (game.active && game.player2 !== '0x0000000000000000000000000000000000000000' &&
                            (game.player1.toLowerCase() === account.toLowerCase() || game.player2.toLowerCase() === account.toLowerCase())) {
                            foundAny = true;
                            let uri1 = await nftContract.tokenURI(game.tokenId1);
                            if (uri1.startsWith('ipfs://')) uri1 = 'https://ipfs.io/ipfs/' + uri1.slice(7);
                            const resp1 = await fetch(uri1);
                            const meta1 = await resp1.json();
                            let img1 = meta1.image;
                            if (img1.startsWith('ipfs://')) img1 = 'https://ipfs.io/ipfs/' + img1.slice(7);

                            let uri2 = await nftContract.tokenURI(game.tokenId2);
                            if (uri2.startsWith('ipfs://')) uri2 = 'https://ipfs.io/ipfs/' + uri2.slice(7);
                            const resp2 = await fetch(uri2);
                            const meta2 = await resp2.json();
                            let img2 = meta2.image;
                            if (img2.startsWith('ipfs://')) img2 = 'https://ipfs.io/ipfs/' + img2.slice(7);

                            const joinedAt = new Date(Number(game.joinTimestamp) * 1000).toLocaleTimeString();
                            const canCancel = currentTime > Number(game.joinTimestamp) + 86400;
                            let actionButton = canCancel ? `<button class="neon-button py-1 px-2 text-xs" onclick="cancelGameFromList(${i})">Cancel</button>` : '<span class="text-xs opacity-70">Waiting for resolution...</span>';
                            listHTML += `
                                <li class="game-card p-3 flex flex-col">
                                    <div class="font-bold text-sm">Game #${i}</div>
                                    <div class="flex gap-3 mt-2">
                                        <div><img src="${img1}" alt="NFT1" class="w-10 h-10 rounded-lg shadow"> NFT #${game.tokenId1}</div>
                                        <div><img src="${img2}" alt="NFT2" class="w-10 h-10 rounded-lg shadow"> NFT #${game.tokenId2}</div>
                                    </div>
                                    <div class="text-xs opacity-70 mt-2">Joined: ${joinedAt}</div>
                                    ${actionButton}
                                </li>`;
                        }
                    } catch (e) {
                        if (e.message.includes('revert') || e.message.includes('out of bounds')) break;
                    }
                }
                ongoingGamesList.innerHTML = foundAny ? listHTML : '<li class="text-center text-sm opacity-70">No ongoing games.</li>';
            } catch (error) {
                updateStatus(`Error fetching ongoing games: ${error.message}`);
                ongoingGamesList.innerHTML = '<li class="text-center text-red-500 text-sm">Error loading games</li>';
            }
        }

        async function fetchTimedOutGames() {
            if (!gameContract) return;
            const timedOutGamesList = document.getElementById('timedOutGamesList');
            let listHTML = '';
            const currentTime = Math.floor(Date.now() / 1000);
            let foundAny = false;
            try {
                for (let i = 0; i < 1000; i++) {
                    try {
                        const game = await gameContract.getGame(i);
                        const canCancel = game.active && game.player2 !== '0x0000000000000000000000000000000000000000' && currentTime > Number(game.joinTimestamp) + 86400;
                        if (canCancel) {
                            foundAny = true;
                            let uri1 = await nftContract.tokenURI(game.tokenId1);
                            if (uri1.startsWith('ipfs://')) uri1 = 'https://ipfs.io/ipfs/' + uri1.slice(7);
                            const resp1 = await fetch(uri1);
                            const meta1 = await resp1.json();
                            let img1 = meta1.image;
                            if (img1.startsWith('ipfs://')) img1 = 'https://ipfs.io/ipfs/' + img1.slice(7);

                            let uri2 = await nftContract.tokenURI(game.tokenId2);
                            if (uri2.startsWith('ipfs://')) uri2 = 'https://ipfs.io/ipfs/' + uri2.slice(7);
                            const resp2 = await fetch(uri2);
                            const meta2 = await resp2.json();
                            let img2 = meta2.image;
                            if (img2.startsWith('ipfs://')) img2 = 'https://ipfs.io/ipfs/' + img2.slice(7);

                            const joinedAt = new Date(Number(game.joinTimestamp) * 1000).toLocaleTimeString();
                            listHTML += `
                                <li class="game-card p-3 flex flex-col">
                                    <div class="font-bold text-sm">Game #${i}</div>
                                    <div class="flex gap-3 mt-2">
                                        <div><img src="${img1}" alt="NFT1" class="w-10 h-10 rounded-lg shadow"> NFT #${game.tokenId1}</div>
                                        <div><img src="${img2}" alt="NFT2" class="w-10 h-10 rounded-lg shadow"> NFT #${game.tokenId2}</div>
                                    </div>
                                    <div class="text-xs opacity-70 mt-2">Joined: ${joinedAt}</div>
                                    <button class="neon-button py-1 px-2 text-xs mt-2" onclick="cancelGameFromList(${i})">Cancel (Timed Out)</button>
                                </li>`;
                        }
                    } catch (e) {
                        if (e.message.includes('revert') || e.message.includes('out of bounds')) break;
                    }
                }
                timedOutGamesList.innerHTML = foundAny ? listHTML : '<li class="text-center text-sm opacity-70">No timed out games.</li>';
            } catch (error) {
                updateStatus(`Error fetching timed out games: ${error.message}`);
                timedOutGamesList.innerHTML = '<li class="text-center text-red-500 text-sm">Error loading games</li>';
            }
        }

        document.getElementById('connectWallet').addEventListener('click', async () => {
            if (!window.ethereum) return updateStatus('Install MetaMask.');
            try {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send("eth_requestAccounts", []);
                signer = provider.getSigner();
                account = await signer.getAddress();
                document.getElementById('accountInfo').textContent = `Account: ${account.slice(0,6)}...${account.slice(-4)}`;
                updateStatus('Wallet connected. Loading contracts...');
                
                gameContract = new ethers.Contract(gameAddress, gameABI, provider);
                gameContractWithSigner = gameContract.connect(signer);
                nftContract = new ethers.Contract(nftAddress, nftABI, signer);
                
                await fetchUserTokens();
                updateStatus('Connected! Fetching games...');
                await fetchOpenGames();
                await fetchOngoingGames();
                await fetchTimedOutGames();
                setupEventListeners();
                
                refreshInterval = setInterval(() => {
                    fetchOpenGames();
                    fetchOngoingGames();
                    fetchTimedOutGames();
                }, 10000);
            } catch (error) {
                updateStatus(`Error: ${error.message}`);
            }
        });

        document.getElementById('createGameBtn').addEventListener('click', async () => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            if (!selectedTokenId) return updateStatus('Select an NFT to bet.');
            try {
                updateStatus('Approving NFT...');
                const approveTx = await nftContract.approve(gameAddress, selectedTokenId);
                await approveTx.wait();
                updateStatus('Approval done. Creating game...');
                const tx = await gameContractWithSigner.createGame(selectedTokenId);
                await tx.wait();
                updateStatus('Game created! Waiting for join...');
                fetchOpenGames();
                fetchUserTokens();
                selectedTokenId = null;
                document.getElementById('selectedNFT').innerHTML = 'None selected';
            } catch (error) {
                updateStatus(`Error creating game: ${error.message}`);
            }
        });

        window.joinGameFromList = async (gameId) => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            if (!selectedTokenId) return updateStatus('Select an NFT to bet.');
            try {
                updateStatus('Approving NFT...');
                const approveTx = await nftContract.approve(gameAddress, selectedTokenId);
                await approveTx.wait();
                updateStatus('Approval done. Joining game...');
                const tx = await gameContractWithSigner.joinGame(gameId, selectedTokenId);
                await tx.wait();
                updateStatus('Joined! Waiting for flip result...');
                fetchOpenGames();
                fetchOngoingGames();
                fetchTimedOutGames();
                fetchUserTokens();
                selectedTokenId = null;
                document.getElementById('selectedNFT').innerHTML = 'None selected';
            } catch (error) {
                updateStatus(`Error joining: ${error.message}`);
            }
        };

        window.cancelUnjoinedFromList = async (gameId) => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            try {
                updateStatus('Canceling unjoined game...');
                const tx = await gameContractWithSigner.cancelUnjoinedGame(gameId);
                await tx.wait();
                updateStatus('Game canceled.');
                fetchOpenGames();
                fetchUserTokens();
            } catch (error) {
                updateStatus(`Error canceling: ${error.message}`);
            }
        };

        window.cancelGameFromList = async (gameId) => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            try {
                updateStatus('Canceling game...');
                const tx = await gameContractWithSigner.cancelGame(gameId);
                await tx.wait();
                updateStatus('Game canceled.');
                fetchOngoingGames();
                fetchTimedOutGames();
                fetchUserTokens();
            } catch (error) {
                updateStatus(`Error canceling: ${error.message}`);
            }
        };

        function playResultVideo(src, text) {
            const video = document.getElementById('resultVideo');
            const overlay = document.getElementById('videoOverlay');
            const resultText = document.getElementById('resultText');

            video.src = src;
            resultText.textContent = text;

            overlay.classList.remove('hidden', 'fade-out');
            setTimeout(() => {
                overlay.classList.add('fade-in');
            }, 10);

            video.play();

            video.onended = () => {
                overlay.classList.remove('fade-in');
                overlay.classList.add('fade-out');
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    overlay.classList.remove('fade-out');
                }, 1000);
            };
        }

        function setupEventListeners() {
            gameContract.on('GameCreated', (gameId, player1, tokenId1) => {
                updateStatus(`New game #${gameId} created by ${player1.slice(0,6)}...`);
                fetchOpenGames();
            });
            gameContract.on('GameJoined', (gameId, player2, tokenId2) => {
                updateStatus(`Game #${gameId} joined by ${player2.slice(0,6)}... Waiting for result...`);
                fetchOpenGames();
                fetchOngoingGames();
                fetchTimedOutGames();
            });
            gameContract.on('RandomnessRequested', (gameId, requestId) => {
                updateStatus(`Flip in progress for #${gameId}...`);
            });
            gameContract.on('GameResolved', (gameId, winner, tokenId1, tokenId2) => {
                const win = winner.toLowerCase() === account.toLowerCase();
                updateStatus(`Game #${gameId} won by ${winner.slice(0,6)}...!`);
                playResultVideo(win ? '/win.mp4' : '/lose.mp4', win ? 'You Win!' : 'You Lose!');
                fetchOpenGames();
                fetchOngoingGames();
                fetchTimedOutGames();
                fetchUserTokens();
            });
            gameContract.on('GameCanceled', (gameId) => {
                updateStatus(`Game #${gameId} canceled.`);
                fetchOpenGames();
                fetchOngoingGames();
                fetchTimedOutGames();
                fetchUserTokens();
            });
        }

        window.addEventListener('beforeunload', () => {
            if (refreshInterval) clearInterval(refreshInterval);
        });
    </script>
</body>
</html>