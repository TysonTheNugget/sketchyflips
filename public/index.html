<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŽ® Sketchy Dapps ðŸŽ²</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.umd.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body>
    <header>
        <h1>ðŸŽ® Sketchy Dapps ðŸŽ²</h1>
        <p>Fun, friends, NFTs!</p>
    </header>

    <main>
        <div id="mainMenu">
            <div>
                <button id="betButton">
                    Bet-A-Sketchy
                    <span id="infoButton">i</span>
                </button>
            </div>
            <button>Stake-A-Milio</button>
        </div>

        <div id="gameInterface">
            <div>
                <button id="connectWallet">ðŸ”Œ Connect Wallet</button>
                <p id="accountInfo">Account: Not connected</p>
            </div>

            <div>
                <p>Selected NFT: <span id="selectedNFT">Your Sketchy</span></p>
                <button id="selectNFTBtn" disabled>ðŸŽ¯ Select NFT</button>
            </div>

            <button id="createGameBtn" disabled>ðŸŽ° Create Game</button>

            <div>
                <p>ðŸŽ¯ Open Games</p>
                <ul id="openGamesList"></ul>
            </div>

            <p id="status">Status: Waiting...</p>
        </div>
    </main>

    <div id="infoModal">
        <div>
            <span class="close">&times;</span>
            <h2>About Bet-A-Sketchy</h2>
            <p>50% chance PVP to win a Sketchy by betting one, verified by Gelato.</p>
            <p>
                <a href="#">ABScan</a> | 
                <a href="#">More Info</a>
            </p>
        </div>
    </div>

    <div id="nftModal">
        <div>
            <span class="close">&times;</span>
            <h2>Select NFT</h2>
            <div id="nftGrid"></div>
        </div>
    </div>

    <div id="resultsModal">
        <div>
            <span class="close">&times;</span>
            <h2>Game Results</h2>
            <ul id="resultsModalList"></ul>
        </div>
    </div>

    <div id="videoOverlay">
        <div id="animationNFTs"></div>
        <video id="resultVideo" autoplay></video>
        <p id="resultText"></p>
    </div>

    <div id="loadingScreen">
        <p>Loading SketchyMilios...</p>
    </div>

    <div>
        <button id="resultsButton">
            Results
            <span id="resultsNotification">0</span>
        </button>
    </div>

    <script>
        const gameABI = [
            "function createGame(uint256 tokenId)",
            "function joinGame(uint256 gameId, uint256 tokenId)",
            "function getOpenGames() view returns (uint256[])",
            "function getGame(uint256 gameId) view returns (tuple(address player1, uint256 tokenId1, address player2, uint256 tokenId2, bool active, uint256 requestId, bytes data, uint256 joinTimestamp, uint256 createTimestamp))",
            "function cancelUnjoinedGame(uint256 gameId)",
            "event GameCreated(uint256 gameId, address player1, uint256 tokenId1)",
            "event GameJoined(uint256 gameId, address player2, uint256 tokenId2)",
            "event RandomnessRequested(uint256 gameId, uint256 requestId)",
            "event GameResolved(uint256 gameId, address winner, uint256 tokenId1, uint256 tokenId2)",
            "event GameCanceled(uint256 gameId)"
        ];

        const nftABI = [
            "function tokensOfOwner(address owner) view returns (uint256[])",
            "function approve(address to, uint256 tokenId)",
            "function tokenURI(uint256 tokenId) view returns (string)"
        ];

        let uiOptions = null;
        let isPlayingResultVideo = false;
        let lastResolvedGames, lastAccount, lastResolveGame;

        function initializeUI({ socket, getAccount, getResolvedGames, getUserTokens, setSelectedTokenId, resolveGame }) {
            uiOptions = { socket, getAccount, getResolvedGames, getUserTokens, setSelectedTokenId, resolveGame };
            
            document.getElementById('infoButton').addEventListener('click', () => {
                console.log('Opening info modal');
                document.getElementById('infoModal').style.display = 'block';
            });

            document.getElementById('betButton').addEventListener('click', () => {
                console.log('Bet-A-Sketchy clicked, showing game interface');
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('gameInterface').classList.remove('hidden');
            });

            document.getElementById('selectNFTBtn').addEventListener('click', () => {
                console.log('Opening NFT selection modal');
                displayNFTsInModal(getUserTokens());
                document.getElementById('nftModal').style.display = 'block';
            });

            document.getElementById('resultsButton').addEventListener('click', (e) => {
                e.stopPropagation();
                console.log('Results button clicked, opening modal');
                updateResultsModal(getResolvedGames(), getAccount(), resolveGame);
                document.getElementById('resultsModal').style.display = 'block';
            });

            document.getElementById('infoModal').querySelector('.close').onclick = () => {
                document.getElementById('infoModal').style.display = 'none';
            };

            document.getElementById('nftModal').querySelector('.close').onclick = () => {
                document.getElementById('nftModal').style.display = 'none';
            };

            document.getElementById('resultsModal').querySelector('.close').onclick = () => {
                console.log('Closing results modal');
                socket.emit('markGamesViewed', { account: getAccount(), gameIds: getResolvedGames().map(g => g.gameId) });
                document.getElementById('resultsModal').style.display = 'none';
            };

            window.onclick = (event) => {
                if (event.target === document.getElementById('infoModal')) {
                    document.getElementById('infoModal').style.display = 'none';
                }
                if (event.target === document.getElementById('nftModal')) {
                    document.getElementById('nftModal').style.display = 'none';
                }
                if (event.target === document.getElementById('resultsModal')) {
                    console.log('Clicked outside results modal');
                    socket.emit('markGamesViewed', { account: getAccount(), gameIds: getResolvedGames().map(g => g.gameId) });
                    document.getElementById('resultsModal').style.display = 'none';
                }
            };
        }

        function showLoadingScreen() {
            console.log('Showing loading screen');
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.classList.remove('hide');
            loadingScreen.classList.add('show');
        }

        function hideLoadingScreen() {
            console.log('Hiding loading screen');
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.classList.remove('show');
            loadingScreen.classList.add('hide');
        }

        function updateStatus(message) {
            console.log('Status update:', message);
            document.getElementById('status').textContent = message;
        }

        function formatTimeRemaining(seconds) {
            if (seconds <= 0) return 'Now';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours > 0 ? hours + 'h ' : ''}${minutes > 0 ? minutes + 'm ' : ''}${secs}s`;
        }

        function displayNFTsInModal(userTokens) {
            console.log('Displaying NFTs in modal, count:', userTokens.length);
            const nftGrid = document.getElementById('nftGrid');
            nftGrid.innerHTML = '';
            if (userTokens.length === 0) {
                nftGrid.innerHTML = '<p>No NFTs available</p>';
                return;
            }
            userTokens.forEach(token => {
                console.log('Creating NFT item for token ID:', token.id);
                const div = document.createElement('div');
                div.className = 'nft-item';
                const img = document.createElement('img');
                img.src = token.image;
                img.alt = `NFT #${token.id}`;
                img.style.pointerEvents = 'none';
                const p = document.createElement('p');
                p.textContent = `#${token.id}`;
                div.appendChild(img);
                div.appendChild(p);
                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('NFT clicked:', token.id);
                    selectNFT(token.id, token.image);
                });
                nftGrid.appendChild(div);
            });
        }

        function selectNFT(tokenId, image) {
            console.log('Selecting NFT with ID:', tokenId);
            if (uiOptions && uiOptions.setSelectedTokenId) {
                uiOptions.setSelectedTokenId(tokenId);
            } else {
                console.error('setSelectedTokenId is not available');
            }
            document.getElementById('selectedNFT').innerHTML = `<img src="${image}" alt="NFT #${tokenId}"><p>NFT #${tokenId}</p>`;
            document.getElementById('nftModal').style.display = 'none';
        }

        function updateOpenGames(games, account) {
            console.log('Updating open games list with:', games);
            const openGamesList = document.getElementById('openGamesList');
            openGamesList.innerHTML = '';
            if (!games || games.length === 0) {
                console.log('No open games to display');
                openGamesList.innerHTML = '<li>No open games.</li>';
                return;
            }
            games.forEach(game => {
                console.log('Rendering game:', game.id, 'Player:', game.player1, 'Token:', game.tokenId1);
                const isMine = account && game.player1.toLowerCase() === account.toLowerCase();
                const currentTime = Math.floor(Date.now() / 1000);
                const timeUntilCancel = Number(game.createTimestamp) + 3600 - currentTime;
                const canCancel = isMine && timeUntilCancel <= 0;
                let actionButton = '';
                if (isMine) {
                    actionButton = canCancel 
                        ? `<button class="cancel-game-btn" data-game-id="${game.id}">Cancel</button>`
                        : `<span>Cancel in ${formatTimeRemaining(timeUntilCancel)}</span>`;
                } else if (account) {
                    actionButton = `<button class="join-game-btn" data-game-id="${game.id}">Join</button>`;
                } else {
                    actionButton = `<span>Connect wallet to join</span>`;
                }
                const li = document.createElement('li');
                li.innerHTML = `
                    <div>
                        <img src="${game.image}" alt="NFT #${game.tokenId1}">
                        <div>
                            <span>Game #${game.id}</span><br>
                            <span>NFT #${game.tokenId1} | ${game.createdAt}</span>
                        </div>
                    </div>
                    ${actionButton}`;
                openGamesList.appendChild(li);
            });

            document.querySelectorAll('.join-game-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const gameId = button.getAttribute('data-game-id');
                    window.joinGameFromList(gameId);
                });
            });
            document.querySelectorAll('.cancel-game-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const gameId = button.getAttribute('data-game-id');
                    window.cancelUnjoinedFromList(gameId);
                });
            });
        }

        function updateResultsModal(resolvedGames, account, resolveGame) {
            lastResolvedGames = resolvedGames;
            lastAccount = account;
            lastResolveGame = resolveGame;
            console.log('Updating results modal with:', resolvedGames);
            const resultsModalList = document.getElementById('resultsModalList');
            resultsModalList.innerHTML = '';
            const userGames = resolvedGames.filter(game => 
                !game.userResolved[account.toLowerCase()] && 
                (game.player1.toLowerCase() === account.toLowerCase() || 
                 (game.player2 && game.player2.toLowerCase() === account.toLowerCase()))
            );
            const unviewedCount = userGames.filter(game => !game.viewed[account.toLowerCase()]).length;
            if (userGames.length === 0) {
                resultsModalList.innerHTML = '<li>No unresolved games.</li>';
                if (!isPlayingResultVideo) {
                    document.getElementById('resultsButton').classList.add('hidden');
                    document.getElementById('resultsNotification').classList.add('hidden');
                }
                return;
            }
            document.getElementById('resultsButton').classList.remove('hidden');
            document.getElementById('resultsNotification').classList.remove('hidden');
            document.getElementById('resultsNotification').textContent = unviewedCount || '0';
            userGames.forEach(game => {
                const isMine = account && (game.player1.toLowerCase() === account.toLowerCase() || 
                                          (game.player2 && game.player2.toLowerCase() === account.toLowerCase()));
                const resolveButton = isMine ? `<button class="resolve-game-btn" data-game-id="${game.gameId}">Resolve</button>` : '';
                const li = document.createElement('li');
                li.innerHTML = `
                    <div>
                        <div>Game #${game.gameId}</div>
                        <div>NFT #${game.tokenId1} vs ${game.tokenId2 || 'N/A'}</div>
                    </div>
                    ${resolveButton}`;
                resultsModalList.appendChild(li);
            });

            document.querySelectorAll('.resolve-game-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const gameId = button.getAttribute('data-game-id');
                    resolveGame(gameId);
                });
            });
        }

        function playResultVideo(src, text, image1, image2) {
            console.log('Playing result video:', src, text, 'Images:', image1, image2);
            isPlayingResultVideo = true;
            const video = document.getElementById('resultVideo');
            const overlay = document.getElementById('videoOverlay');
            const resultText = document.getElementById('resultText');
            const animationNFTs = document.getElementById('animationNFTs');

            const validImage1 = image1 && image1 !== 'undefined' ? image1 : 'https://via.placeholder.com/64';
            const validImage2 = image2 && image2 !== 'undefined' ? image2 : 'https://via.placeholder.com/64';

            animationNFTs.innerHTML = `
                <img src="${validImage1}" alt="NFT1" onerror="this.src='https://via.placeholder.com/64';">
                <img src="${validImage2}" alt="NFT2" onerror="this.src='https://via.placeholder.com/64';">
            `;
            video.src = src;
            resultText.textContent = text;

            overlay.classList.remove('hidden', 'fade-out');
            setTimeout(() => {
                overlay.classList.add('fade-in');
            }, 10);

            video.play().catch(error => {
                console.error('Error playing video:', error);
                updateStatus(`Error playing result video: ${error.message}`);
                overlay.classList.remove('fade-in');
                overlay.classList.add('fade-out');
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    overlay.classList.remove('fade-out');
                    animationNFTs.innerHTML = '';
                }, 800);
                isPlayingResultVideo = false;
                if (lastResolvedGames && lastAccount && lastResolveGame) {
                    updateResultsModal(lastResolvedGames, lastAccount, lastResolveGame);
                }
            });

            video.onended = () => {
                console.log('Video ended, hiding overlay');
                overlay.classList.remove('fade-in');
                overlay.classList.add('fade-out');
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    overlay.classList.remove('fade-out');
                    animationNFTs.innerHTML = '';
                }, 800);
                isPlayingResultVideo = false;
                if (lastResolvedGames && lastAccount && lastResolveGame) {
                    updateResultsModal(lastResolvedGames, lastAccount, lastResolveGame);
                }
            };
        }

        const gameAddress = '0xf6b8d2E0d36669Ed82059713BDc6ACfABe11Fde6';
        const nftAddress = '0x08533a2b16e3db03eebd5b23210122f97dfcb97d';
        const socket = io('https://sketchyflipback.onrender.com', {
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });

        let provider, signer, account, gameContract, gameContractWithSigner, nftContract;
        let selectedTokenId = null;
        let userTokens = [];
        let resolvedGames = [];
        let isResolving = false;

        function resolveGame(gameId) {
            if (isResolving) {
                console.log('Resolve already in progress, ignoring click for game:', gameId);
                return;
            }
            isResolving = true;
            console.log('Resolving game:', gameId, 'for account:', account);
            updateStatus('Loading... Checking game resolution...');
            socket.emit('resolveGame', { gameId, account });
            setTimeout(() => {
                if (isResolving) {
                    isResolving = false;
                    updateStatus('Resolution timed out, please try again.');
                    socket.emit('fetchResolvedGames', { account });
                }
            }, 30000);
        }

        initializeUI({ 
            socket, 
            getAccount: () => account, 
            getResolvedGames: () => resolvedGames, 
            getUserTokens: () => userTokens, 
            setSelectedTokenId: (id) => { selectedTokenId = id; },
            resolveGame
        });

        document.getElementById('connectWallet').addEventListener('click', async () => {
            if (!window.ethereum) {
                updateStatus('Install MetaMask.');
                return;
            }
            try {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send("eth_requestAccounts", []);
                signer = provider.getSigner();
                account = await signer.getAddress();
                document.getElementById('accountInfo').textContent = `Account: ${account.slice(0,6)}...${account.slice(-4)}`;
                updateStatus('Wallet connected...');
                
                gameContract = new ethers.Contract(gameAddress, gameABI, provider);
                gameContractWithSigner = gameContract.connect(signer);
                nftContract = new ethers.Contract(nftAddress, nftABI, signer);
                
                socket.emit('registerAddress', { address: account });
                await fetchUserTokens(true);
                updateStatus('Connected! Fetching games...');
                socket.emit('fetchResolvedGames', { account });
            } catch (error) {
                console.error('Error connecting wallet:', error);
                updateStatus(`Connection error: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        });

        document.getElementById('createGameBtn').addEventListener('click', async () => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            if (!selectedTokenId) return updateStatus('Select an NFT to bet.');
            try {
                updateStatus('Approving NFT...');
                const approveTx = await nftContract.approve(gameAddress, selectedTokenId);
                await approveTx.wait();
                updateStatus('Creating game...');
                const tx = await gameContractWithSigner.createGame(selectedTokenId);
                await tx.wait();
                updateStatus('Game created! Waiting for join...');
                await fetchUserTokens();
                selectedTokenId = null;
                document.getElementById('selectedNFT').innerHTML = 'Your Sketchy';
            } catch (error) {
                console.error('Error creating game:', error);
                updateStatus(`Error creating game: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        });

        window.joinGameFromList = async (gameId) => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            if (!selectedTokenId) return updateStatus('Select an NFT to bet.');
            try {
                updateStatus('Approving NFT...');
                const approveTx = await nftContract.approve(gameAddress, selectedTokenId);
                await approveTx.wait();
                updateStatus('Joining game...');
                const tx = await gameContractWithSigner.joinGame(gameId, selectedTokenId);
                await tx.wait();
                updateStatus('Joined! Waiting for result...');
                await fetchUserTokens();
                selectedTokenId = null;
                document.getElementById('selectedNFT').innerHTML = 'Your Sketchy';
            } catch (error) {
                console.error('Error joining game:', error);
                updateStatus(`Error joining: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        };

        window.cancelUnjoinedFromList = async (gameId) => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            try {
                updateStatus('Canceling game...');
                const tx = await gameContractWithSigner.cancelUnjoinedGame(gameId);
                await tx.wait();
                updateStatus('Game canceled.');
                await fetchUserTokens();
            } catch (error) {
                console.error('Error canceling unjoined game:', error);
                updateStatus(`Error canceling: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        };

        async function fetchUserTokens(showLoading = false) {
            if (!nftContract || !account) {
                console.log('Cannot fetch tokens: nftContract or account missing');
                return;
            }
            if (showLoading) showLoadingScreen();
            userTokens = [];
            const nftGrid = document.getElementById('nftGrid');
            nftGrid.innerHTML = '<p>Loading NFTs...</p>';
            try {
                console.log('Fetching tokens for account:', account);
                const tokens = await nftContract.tokensOfOwner(account);
                console.log('Tokens fetched:', tokens);
                for (let id of tokens) {
                    let uri = await nftContract.tokenURI(id);
                    if (uri.startsWith('ipfs://')) uri = 'https://ipfs.io/ipfs/' + uri.slice(7);
                    const response = await fetch(uri);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const metadata = await response.json();
                    let image = metadata.image;
                    if (image && image.startsWith('ipfs://')) image = 'https://ipfs.io/ipfs/' + image.slice(7);
                    userTokens.push({ id: id.toString(), image: image || 'https://via.placeholder.com/64' });
                }
                console.log('User tokens loaded:', userTokens);
                document.getElementById('selectNFTBtn').disabled = userTokens.length === 0;
                document.getElementById('createGameBtn').disabled = userTokens.length === 0;
                if (userTokens.length === 0) {
                    nftGrid.innerHTML = '<p>No NFTs owned</p>';
                } else {
                    displayNFTsInModal(userTokens);
                }
                if (showLoading) hideLoadingScreen();
            } catch (error) {
                console.error('Error fetching tokens:', error);
                updateStatus(`Tokens fetch error: ${error.message}`);
                nftGrid.innerHTML = '<p>Error loading NFTs</p>';
                if (showLoading) hideLoadingScreen();
            }
        }

        socket.on('connect', () => {
            console.log('Connected to backend:', socket.id);
            if (account) {
                socket.emit('registerAddress', { address: account });
            }
            updateStatus('Connected to backend, waiting for games...');
        });

        socket.on('openGamesUpdate', (games) => {
            console.log('Received openGamesUpdate:', games);
            updateOpenGames(games, account);
        });

        socket.on('gameJoined', async (data) => {
            console.log('Received gameJoined:', data);
            resolvedGames.push({ 
                gameId: data.gameId, 
                player1: data.player1, 
                tokenId1: data.tokenId1, 
                image1: data.image1,
                player2: data.player2, 
                tokenId2: data.tokenId2, 
                image2: data.image2,
                resolved: false, 
                userResolved: { [account.toLowerCase()]: false }, 
                viewed: { [account.toLowerCase()]: false }
            });
            updateResultsModal(resolvedGames, account);
            updateStatus(`Game #${data.gameId} joined by ${data.player2.slice(0, 6)}...${data.player2.slice(-4)}`);
            await fetchUserTokens();
        });

        socket.on('resolvedGames', (games) => {
            console.log('Received resolvedGames:', games);
            resolvedGames = games.map(game => ({
                ...game,
                userResolved: game.userResolved || { [account.toLowerCase()]: false },
                viewed: game.viewed || { [account.toLowerCase()]: false }
            }));
            updateResultsModal(resolvedGames, account);
        });

        socket.on('gameResolution', async (data) => {
            console.log('Received gameResolution:', data);
            if (data.error) {
                if (data.error === 'Game not resolved or no winner') {
                    console.log(`Game ${data.gameId} not yet resolved, retrying...`);
                    setTimeout(() => {
                        socket.emit('fetchResolvedGames', { account });
                    }, 3000);
                    return;
                }
                updateStatus(`Error resolving game #${data.gameId}: ${data.error}`);
                isResolving = false;
                return;
            }
            isResolving = false;
            const win = account && data.winner && data.winner.toLowerCase() === account.toLowerCase();
            updateStatus(`Game #${data.gameId} resolved: ${win ? 'You Win!' : 'You Lose!'}`);
            playResultVideo(
                win ? '/win.mp4' : '/lose.mp4', 
                win ? 'You Win!' : 'You Lose!', 
                data.image1 || 'https://via.placeholder.com/64', 
                data.image2 || 'https://via.placeholder.com/64'
            );
            socket.emit('fetchResolvedGames', { account });
            await fetchUserTokens();
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from backend');
            updateStatus('Disconnected from backend, attempting reconnect...');
        });

        socket.on('connect_error', (error) => {
            console.error('Socket connection error:', error);
            updateStatus(`Socket connection error: ${error.message}`);
        });

        socket.on('reconnect', (attempt) => {
            console.log('Reconnected to backend after attempt:', attempt);
            if (account) {
                socket.emit('registerAddress', { address: account });
            }
            updateStatus('Reconnected to backend!');
        });

        socket.on('reconnect_error', (error) => {
            console.error('Socket reconnection error:', error);
            updateStatus(`Socket reconnection error: ${error.message}`);
        });
    </script>
</body>
</html>