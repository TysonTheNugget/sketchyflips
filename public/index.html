<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sketchy Flips - Arcade Playground</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
        body {
            background-image: url('/background.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
        }
        @media (max-width: 768px) {
            html, body {
                overflow-y: auto;
            }
            #gameInterface {
                height: auto;
                min-height: 100vh;
            }
        }
        .neon-button {
            background: linear-gradient(to right, #ffeb3b, #ff9800);
            color: black;
            font-weight: bold;
            border-radius: 1rem;
            padding: 0.3rem 0.8rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-size: 0.8rem;
            border: 1px solid #ff9800;
            cursor: pointer;
            pointer-events: auto;
        }
        .neon-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 6px rgba(255, 152, 0, 0.5), 0 0 15px rgba(255, 235, 59, 0.3);
        }
        .game-card {
            background: white;
            border-radius: 0.75rem;
            border: 1px solid #ff9800;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }
        .game-card:hover {
            transform: translateY(-3px);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 50;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            padding-top: 40px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 10px;
            width: 90%;
            max-width: 400px;
            border-radius: 0.75rem;
            border: 1px solid #ff9800;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            position: relative;
            z-index: 51;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
        }
        .nft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.5rem;
            pointer-events: auto;
        }
        .nft-item {
            cursor: pointer;
            text-align: center;
            transition: transform 0.2s ease;
            pointer-events: auto;
            z-index: 52;
        }
        .nft-item:hover {
            transform: scale(1.05);
        }
        .nft-item img {
            width: 100%;
            height: auto;
            border-radius: 0.5rem;
            border: 1px solid #ff9800;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #videoOverlay {
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
            z-index: 70;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #videoOverlay.fade-in {
            opacity: 1;
        }
        #videoOverlay.fade-out {
            opacity: 0;
        }
        .info-button {
            background-color: #ff9800;
            color: white;
            font-weight: bold;
            border-radius: 50%;
            width: 1rem;
            height: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
            font-size: 0.6rem;
            border: 1px solid #fff;
        }
        .info-button:hover {
            transform: scale(1.1);
        }
        .status-pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #loadingScreen.show {
            opacity: 1;
        }
        #loadingScreen.hide {
            opacity: 0;
            pointer-events: none;
        }
        #loadingText {
            color: #fff;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 0 10px #ff9800;
            animation: fadeText 1.5s infinite;
            border: 2px solid #ff9800;
            padding: 10px;
            border-radius: 0.5rem;
        }
        @keyframes fadeText {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        #openGamesList {
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #ff9800 #f0f0f0;
        }
        #openGamesList::-webkit-scrollbar {
            width: 8px;
        }
        #openGamesList::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 4px;
        }
        #openGamesList::-webkit-scrollbar-thumb {
            background: #ff9800;
            border-radius: 4px;
        }
        #resultsButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(to right, #ff0000, #ff4500);
            color: white;
            font-weight: bold;
            border-radius: 1rem;
            padding: 0.5rem 1rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 80;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            pointer-events: auto;
        }
        #resultsButton:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(255, 69, 0, 0.5);
        }
        #resultsNotification {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: red;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #resultsModalList {
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #ff9800 #f0f0f0;
        }
        #resultsModalList::-webkit-scrollbar {
            width: 8px;
        }
        #resultsModalList::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 4px;
        }
        #resultsModalList::-webkit-scrollbar-thumb {
            background: #ff9800;
            border-radius: 4px;
        }
        #animationNFTs {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }
        #animationNFTs img {
            width: 64px;
            height: 64px;
            border-radius: 0.5rem;
            border: 1px solid #ff9800;
        }
    </style>
</head>
<body class="text-black">
    <!-- Header -->
    <header class="w-full text-center py-2 bg-gradient-to-r from-yellow-400 to-orange-500 shadow-sm">
        <h1 class="text-xl md:text-2xl font-extrabold text-white">ðŸŽ® Sketchy Flips ðŸŽ²</h1>
        <p class="text-xs md:text-sm text-white">Fun, friends, NFTs!</p>
    </header>

    <!-- Main Menu -->
    <div id="mainMenu" class="w-full max-w-2xl p-2 flex flex-col items-center justify-center">
        <div class="flex flex-col sm:flex-row justify-center gap-2">
            <div class="relative">
                <button id="betButton" class="neon-button">Bet-A-Sketchy</button>
                <button id="infoButton" class="info-button absolute -top-1 -right-1">i</button>
            </div>
            <button class="neon-button opacity-50 cursor-not-allowed">Stake-A-Milio (Soon)</button>
        </div>
    </div>

    <!-- Game Interface -->
    <div id="gameInterface" class="hidden w-full max-w-4xl p-2 flex flex-col gap-2 h-[calc(100vh-80px)]">
        <!-- Controls -->
        <div class="w-full flex flex-col gap-2">
            <button id="connectWallet" class="neon-button">ðŸ”Œ Connect Wallet</button>
            <p id="accountInfo" class="game-card p-1 text-center text-xs">Account: Not connected</p>
            <div class="game-card p-2">
                <label class="block font-bold text-xs mb-1">Selected NFT:</label>
                <div id="selectedNFT" class="w-full p-1 rounded-lg border border-orange-500 bg-white text-center text-xs">Your Sketchy</div>
                <button id="selectNFTBtn" disabled class="neon-button w-full mt-1">ðŸŽ¯ Select NFT</button>
            </div>
            <button id="createGameBtn" disabled class="neon-button w-full">ðŸŽ° Create Game</button>
            <div class="game-card p-2 flex-grow">
                <h2 class="text-sm text-center mb-1 font-bold">ðŸŽ¯ Open Games</h2>
                <ul id="openGamesList" class="space-y-2 overflow-y-auto"></ul>
            </div>
            <div class="game-card p-2 text-center text-xs font-bold status-pulse">Status: <span id="status">Waiting...</span></div>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close">Ã—</span>
            <h2 class="text-lg text-center mb-2 font-bold">About Bet-A-Sketchy</h2>
            <p class="text-center text-xs">50% chance PVP to win a Sketchy by betting one, verified by Gelato. 
                <a href="https://abscan.org/address/0xf6b8d2E0d36669Ed82059713BDc6ACfABe11Fde6#code" target="_blank" class="text-blue-500 hover:underline">ABScan</a> | 
                <a href="/moreinfo.html" target="_blank" class="text-blue-500 hover:underline">More Info</a>
            </p>
        </div>
    </div>

    <!-- NFT Selection Modal -->
    <div id="nftModal" class="modal">
        <div class="modal-content">
            <span class="close">Ã—</span>
            <h2 class="text-lg text-center mb-2 font-bold">Select NFT</h2>
            <div id="nftGrid" class="nft-grid"></div>
        </div>
    </div>

    <!-- Results Modal -->
    <div id="resultsModal" class="modal">
        <div class="modal-content">
            <span class="close">Ã—</span>
            <h2 class="text-lg text-center mb-2 font-bold">Game Results</h2>
            <ul id="resultsModalList" class="space-y-2"></ul>
        </div>
    </div>

    <!-- Video Overlay -->
    <div id="videoOverlay" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-70 hidden">
        <div class="relative">
            <div id="animationNFTs"></div>
            <video id="resultVideo" class="max-w-full max-h-64 rounded-lg border border-orange-500" playsinline muted></video>
            <div id="resultText" class="absolute inset-0 flex items-center justify-center text-white text-3xl font-bold" style="text-shadow: 1px 1px 3px black;"></div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen" class="hide">
        <div id="loadingText">Loading SketchyMilios...</div>
    </div>

    <!-- Results Button -->
    <button id="resultsButton" class="neon-button hidden">
        Results
        <span id="resultsNotification" class="hidden">0</span>
    </button>

    <script>
        let provider, signer, account, gameContract, gameContractWithSigner, nftContract;
        const gameAddress = '0xf6b8d2E0d36669Ed82059713BDc6ACfABe11Fde6';
        const nftAddress = '0x08533a2b16e3db03eebd5b23210122f97dfcb97d';
        const socket = io('https://sketchyflipback.onrender.com', {
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });

        const gameABI = [
            "function createGame(uint256 tokenId)",
            "function joinGame(uint256 gameId, uint256 tokenId)",
            "function getOpenGames() view returns (uint256[])",
            "function getGame(uint256 gameId) view returns (tuple(address player1, uint256 tokenId1, address player2, uint256 tokenId2, bool active, uint256 requestId, bytes data, uint256 joinTimestamp, uint256 createTimestamp))",
            "function cancelUnjoinedGame(uint256 gameId)",
            "event GameCreated(uint256 gameId, address player1, uint256 tokenId1)",
            "event GameJoined(uint256 gameId, address player2, uint256 tokenId2)",
            "event RandomnessRequested(uint256 gameId, uint256 requestId)",
            "event GameResolved(uint256 gameId, address winner, uint256 tokenId1, uint256 tokenId2)",
            "event GameCanceled(uint256 gameId)"
        ];

        const nftABI = [
            "function tokensOfOwner(address owner) view returns (uint256[])",
            "function approve(address to, uint256 tokenId)",
            "function tokenURI(uint256 tokenId) view returns (string)"
        ];

        let selectedTokenId = null;
        let userTokens = [];
        let resolvedGames = [];

        // Modals and Loading Screen
        const infoModal = document.getElementById('infoModal');
        const nftModal = document.getElementById('nftModal');
        const resultsModal = document.getElementById('resultsModal');
        const loadingScreen = document.getElementById('loadingScreen');
        const infoClose = infoModal.querySelector('.close');
        const nftClose = nftModal.querySelector('.close');
        const resultsClose = resultsModal.querySelector('.close');
        const nftGrid = document.getElementById('nftGrid');
        const selectNFTBtn = document.getElementById('selectNFTBtn');
        const resultsButton = document.getElementById('resultsButton');
        const resultsNotification = document.getElementById('resultsNotification');

        infoClose.onclick = () => { infoModal.style.display = 'none'; };
        nftClose.onclick = () => { nftModal.style.display = 'none'; };
        resultsClose.onclick = () => { 
            console.log('Closing results modal');
            socket.emit('markGamesViewed', { account, gameIds: resolvedGames.filter(g => !g.userResolved).map(g => g.gameId) });
            resultsModal.style.display = 'none'; 
        };
        window.onclick = (event) => {
            if (event.target === infoModal) infoModal.style.display = 'none';
            if (event.target === nftModal) nftModal.style.display = 'none';
            if (event.target === resultsModal) {
                console.log('Clicked outside results modal');
                socket.emit('markGamesViewed', { account, gameIds: resolvedGames.filter(g => !g.userResolved).map(g => g.gameId) });
                resultsModal.style.display = 'none';
            }
        };

        document.getElementById('infoButton').addEventListener('click', () => {
            console.log('Opening info modal');
            infoModal.style.display = 'block';
        });

        document.getElementById('betButton').addEventListener('click', () => {
            console.log('Bet-A-Sketchy clicked, showing game interface');
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('gameInterface').classList.remove('hidden');
        });

        selectNFTBtn.addEventListener('click', () => {
            console.log('Opening NFT selection modal');
            displayNFTsInModal();
            nftModal.style.display = 'block';
        });

        resultsButton.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Results button clicked, opening modal');
            updateResultsModal();
            resultsModal.style.display = 'block';
        });

        function showLoadingScreen() {
            console.log('Showing loading screen');
            loadingScreen.classList.remove('hide');
            loadingScreen.classList.add('show');
        }

        function hideLoadingScreen() {
            console.log('Hiding loading screen');
            loadingScreen.classList.remove('show');
            loadingScreen.classList.add('hide');
        }

        function updateStatus(message) {
            console.log('Status update:', message);
            document.getElementById('status').textContent = message;
        }

        function formatTimeRemaining(seconds) {
            if (seconds <= 0) return 'Now';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours > 0 ? hours + 'h ' : ''}${minutes > 0 ? minutes + 'm ' : ''}${secs}s`;
        }

        async function fetchUserTokens(showLoading = false) {
            if (!nftContract || !account) {
                console.log('Cannot fetch tokens: nftContract or account missing');
                return;
            }
            if (showLoading) showLoadingScreen();
            userTokens = [];
            nftGrid.innerHTML = '<p class="text-center text-xs">Loading NFTs...</p>';
            try {
                console.log('Fetching tokens for account:', account);
                const tokens = await nftContract.tokensOfOwner(account);
                console.log('Tokens fetched:', tokens);
                for (let id of tokens) {
                    let uri = await nftContract.tokenURI(id);
                    if (uri.startsWith('ipfs://')) uri = 'https://ipfs.io/ipfs/' + uri.slice(7);
                    const response = await fetch(uri);
                    const metadata = await response.json();
                    let image = metadata.image;
                    if (image.startsWith('ipfs://')) image = 'https://ipfs.io/ipfs/' + image.slice(7);
                    userTokens.push({ id: id.toString(), image });
                }
                console.log('User tokens loaded:', userTokens);
                selectNFTBtn.disabled = userTokens.length === 0;
                document.getElementById('createGameBtn').disabled = userTokens.length === 0;
                if (userTokens.length === 0) {
                    nftGrid.innerHTML = '<p class="text-center text-xs">No NFTs owned</p>';
                } else {
                    displayNFTsInModal();
                }
                if (showLoading) hideLoadingScreen();
            } catch (error) {
                console.error('Error fetching tokens:', error);
                updateStatus(`Tokens fetch error: ${error.message}`);
                nftGrid.innerHTML = '<p class="text-center text-red-500 text-xs">Error loading NFTs</p>';
                if (showLoading) hideLoadingScreen();
            }
        }

        function displayNFTsInModal() {
            console.log('Displaying NFTs in modal, count:', userTokens.length);
            nftGrid.innerHTML = '';
            if (userTokens.length === 0) {
                nftGrid.innerHTML = '<p class="text-center text-xs">No NFTs available</p>';
                return;
            }
            userTokens.forEach(token => {
                console.log('Creating NFT item for token ID:', token.id);
                const div = document.createElement('div');
                div.className = 'nft-item';
                const img = document.createElement('img');
                img.src = token.image;
                img.alt = `NFT #${token.id}`;
                img.style.pointerEvents = 'none';
                const p = document.createElement('p');
                p.className = 'text-xs';
                p.textContent = `#${token.id}`;
                div.appendChild(img);
                div.appendChild(p);
                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('NFT clicked:', token.id);
                    selectNFT(token.id, token.image);
                });
                nftGrid.appendChild(div);
            });
        }

        function selectNFT(tokenId, image) {
            console.log('Selecting NFT with ID:', tokenId);
            selectedTokenId = tokenId;
            document.getElementById('selectedNFT').innerHTML = `<img src="${image}" alt="NFT #${tokenId}" class="w-8 h-8 inline-block mr-1 rounded border border-orange-500"><p class="inline text-xs">NFT #${tokenId}</p>`;
            nftModal.style.display = 'none';
        }

        function updateOpenGames(games) {
            console.log('Updating open games list with:', games);
            const openGamesList = document.getElementById('openGamesList');
            openGamesList.innerHTML = '';
            if (!games || games.length === 0) {
                console.log('No open games to display');
                openGamesList.innerHTML = '<li class="text-center text-xs opacity-70">No open games.</li>';
                return;
            }
            games.forEach(game => {
                console.log('Rendering game:', game.id, 'Player:', game.player1, 'Token:', game.tokenId1);
                const isMine = account && game.player1.toLowerCase() === account.toLowerCase();
                const currentTime = Math.floor(Date.now() / 1000);
                const timeUntilCancel = Number(game.createTimestamp) + 3600 - currentTime;
                const canCancel = isMine && timeUntilCancel <= 0;
                let actionButton = '';
                if (isMine) {
                    actionButton = canCancel 
                        ? `<button class="neon-button py-0.5 px-1 text-xs" onclick="cancelUnjoinedFromList(${game.id})">Cancel</button>`
                        : `<span class="text-xs opacity-70">Cancel in ${formatTimeRemaining(timeUntilCancel)}</span>`;
                } else if (account) {
                    actionButton = `<button class="neon-button py-0.5 px-1 text-xs" onclick="joinGameFromList(${game.id})">Join</button>`;
                } else {
                    actionButton = `<span class="text-xs opacity-70">Connect wallet to join</span>`;
                }
                const li = document.createElement('li');
                li.className = 'game-card p-2 flex justify-between items-center';
                li.innerHTML = `
                    <div class="flex items-center">
                        <img src="${game.image}" alt="NFT #${game.tokenId1}" class="w-8 h-8 mr-2 rounded shadow border border-orange-500">
                        <div>
                            <span class="font-bold text-xs">Game #${game.id}</span><br>
                            <span class="text-xs opacity-70">NFT #${game.tokenId1} | ${game.createdAt}</span>
                        </div>
                    </div>
                    ${actionButton}`;
                openGamesList.appendChild(li);
            });
        }

        function updateResultsModal() {
            console.log('Updating results modal with:', resolvedGames);
            const resultsModalList = document.getElementById('resultsModalList');
            resultsModalList.innerHTML = '';
            const userGames = resolvedGames.filter(game => 
                !game.userResolved[account.toLowerCase()] && 
                (game.player1.toLowerCase() === account.toLowerCase() || 
                 (game.player2 && game.player2.toLowerCase() === account.toLowerCase()))
            );
            const unviewedCount = userGames.filter(game => !game.viewed[account.toLowerCase()]).length;
            if (userGames.length === 0) {
                resultsModalList.innerHTML = '<li class="text-center text-xs opacity-70">No unresolved games.</li>';
                resultsButton.classList.add('hidden');
                resultsNotification.classList.add('hidden');
                return;
            }
            resultsButton.classList.remove('hidden');
            resultsNotification.classList.remove('hidden');
            resultsNotification.textContent = unviewedCount || '0';
            userGames.forEach(game => {
                const isMine = account && (game.player1.toLowerCase() === account.toLowerCase() || 
                                          (game.player2 && game.player2.toLowerCase() === account.toLowerCase()));
                const resolveButton = isMine ? `<button class="neon-button py-0.5 px-1 text-xs" onclick="resolveGame(${game.gameId})">Resolve</button>` : '';
                const li = document.createElement('li');
                li.className = 'game-card p-2 flex justify-between items-center';
                li.innerHTML = `
                    <div>
                        <div class="font-bold text-xs">Game #${game.gameId}</div>
                        <div class="text-xs">NFT #${game.tokenId1} vs ${game.tokenId2 || 'N/A'}</div>
                    </div>
                    ${resolveButton}`;
                resultsModalList.appendChild(li);
            });
        }

        async function resolveGame(gameId) {
            console.log('Resolving game:', gameId);
            socket.emit('resolveGame', { gameId, account });
            updateStatus('Checking game resolution...');
        }

        document.getElementById('connectWallet').addEventListener('click', async () => {
            if (!window.ethereum) {
                updateStatus('Install MetaMask.');
                return;
            }
            try {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send("eth_requestAccounts", []);
                signer = provider.getSigner();
                account = await signer.getAddress();
                document.getElementById('accountInfo').textContent = `Account: ${account.slice(0,6)}...${account.slice(-4)}`;
                updateStatus('Wallet connected...');
                
                gameContract = new ethers.Contract(gameAddress, gameABI, provider);
                gameContractWithSigner = gameContract.connect(signer);
                nftContract = new ethers.Contract(nftAddress, nftABI, signer);
                
                await fetchUserTokens(true);
                updateStatus('Connected! Fetching games...');
                socket.emit('fetchResolvedGames', { account });
            } catch (error) {
                console.error('Error connecting wallet:', error);
                updateStatus(`Connection error: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        });

        document.getElementById('createGameBtn').addEventListener('click', async () => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            if (!selectedTokenId) return updateStatus('Select an NFT to bet.');
            try {
                updateStatus('Approving NFT...');
                const approveTx = await nftContract.approve(gameAddress, selectedTokenId);
                await approveTx.wait();
                updateStatus('Creating game...');
                const tx = await gameContractWithSigner.createGame(selectedTokenId);
                await tx.wait();
                updateStatus('Game created! Waiting for join...');
                await fetchUserTokens();
                selectedTokenId = null;
                document.getElementById('selectedNFT').innerHTML = 'Your Sketchy';
            } catch (error) {
                console.error('Error creating game:', error);
                updateStatus(`Error creating game: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        });

        window.joinGameFromList = async (gameId) => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            if (!selectedTokenId) return updateStatus('Select an NFT to bet.');
            try {
                updateStatus('Approving NFT...');
                const approveTx = await nftContract.approve(gameAddress, selectedTokenId);
                await approveTx.wait();
                updateStatus('Joining game...');
                const tx = await gameContractWithSigner.joinGame(gameId, selectedTokenId);
                await tx.wait();
                updateStatus('Joined! Waiting for result...');
                await fetchUserTokens();
                selectedTokenId = null;
                document.getElementById('selectedNFT').innerHTML = 'Your Sketchy';
            } catch (error) {
                console.error('Error joining game:', error);
                updateStatus(`Error joining: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        };

        window.cancelUnjoinedFromList = async (gameId) => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            try {
                updateStatus('Canceling game...');
                const tx = await gameContractWithSigner.cancelUnjoinedGame(gameId);
                await tx.wait();
                updateStatus('Game canceled.');
                await fetchUserTokens();
            } catch (error) {
                console.error('Error canceling unjoined game:', error);
                updateStatus(`Error canceling: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        };

        function playResultVideo(src, text, image1, image2) {
            console.log('Playing result video:', src, text);
            const video = document.getElementById('resultVideo');
            const overlay = document.getElementById('videoOverlay');
            const resultText = document.getElementById('resultText');
            const animationNFTs = document.getElementById('animationNFTs');

            animationNFTs.innerHTML = `
                <img src="${image1}" alt="NFT1">
                <img src="${image2 || 'https://via.placeholder.com/64'}" alt="NFT2">
            `;
            video.src = src;
            resultText.textContent = text;

            overlay.classList.remove('hidden', 'fade-out');
            setTimeout(() => {
                overlay.classList.add('fade-in');
            }, 10);

            video.play().catch(error => {
                console.error('Error playing video:', error);
                updateStatus(`Error playing result video: ${error.message}`);
                overlay.classList.remove('fade-in');
                overlay.classList.add('fade-out');
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    overlay.classList.remove('fade-out');
                    animationNFTs.innerHTML = '';
                }, 800);
            });

            video.onended = () => {
                console.log('Video ended, hiding overlay');
                overlay.classList.remove('fade-in');
                overlay.classList.add('fade-out');
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    overlay.classList.remove('fade-out');
                    animationNFTs.innerHTML = '';
                }, 800);
            };
        }

        // Socket.IO event listeners
        socket.on('connect', () => {
            console.log('Connected to backend:', socket.id);
            updateStatus('Connected to backend, waiting for games...');
        });

        socket.on('openGamesUpdate', (games) => {
            console.log('Received openGamesUpdate:', games);
            updateOpenGames(games);
        });

        socket.on('gameJoined', async (data) => {
            console.log('Received gameJoined:', data);
            resolvedGames.push({ 
                gameId: data.gameId, 
                player1: data.player1, 
                tokenId1: data.tokenId1, 
                image1: data.image1,
                player2: data.player2, 
                tokenId2: data.tokenId2, 
                image2: data.image2,
                resolved: false, 
                userResolved: { [account.toLowerCase()]: false }, 
                viewed: { [account.toLowerCase()]: false }
            });
            updateResultsModal();
            updateStatus(`Game #${data.gameId} joined by ${data.player2.slice(0, 6)}...${data.player2.slice(-4)}`);
            await fetchUserTokens();
        });

        socket.on('resolvedGames', (games) => {
            console.log('Received resolvedGames:', games);
            resolvedGames = games.map(game => ({
                ...game,
                userResolved: game.userResolved || { [account.toLowerCase()]: false },
                viewed: game.viewed || { [account.toLowerCase()]: false }
            }));
            updateResultsModal();
        });

        socket.on('gameResolution', async (data) => {
            console.log('Received gameResolution:', data);
            if (data.error) {
                updateStatus(`Error resolving game #${data.gameId}: ${data.error}`);
                return;
            }
            resolvedGames = resolvedGames.map(game => 
                game.gameId === data.gameId ? { 
                    ...game, 
                    winner: data.winner, 
                    resolved: true, 
                    userResolved: { ...game.userResolved, [account.toLowerCase()]: true }, 
                    viewed: { ...game.viewed, [account.toLowerCase()]: false },
                    image1: data.image1,
                    image2: data.image2
                } : game
            );
            const win = account && data.winner && data.winner.toLowerCase() === account.toLowerCase();
            updateStatus(`Game #${data.gameId} resolved: ${win ? 'You Win!' : 'You Lose!'}`);
            updateResultsModal();
            playResultVideo(
                win ? '/win.mp4' : '/lose.mp4', 
                win ? 'You Win!' : 'You Lose!', 
                data.image1, 
                data.image2
            );
            await fetchUserTokens();
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from backend');
            updateStatus('Disconnected from backend, attempting reconnect...');
        });

        socket.on('connect_error', (error) => {
            console.error('Socket connection error:', error);
            updateStatus(`Socket connection error: ${error.message}`);
        });

        socket.on('reconnect', (attempt) => {
            console.log('Reconnected to backend after attempt:', attempt);
            updateStatus('Reconnected to backend!');
        });

        socket.on('reconnect_error', (error) => {
            console.error('Socket reconnection error:', error);
            updateStatus(`Socket reconnection error: ${error.message}`);
        });
    </script>
</body>
</html>