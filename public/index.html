<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŽ® Sketchy Dapps ðŸŽ²</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" type="text/javascript"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body>

    <header class="text-center mb-8">
        <h1 class="text-4xl font-bold">ðŸŽ® Sketchy Dapps ðŸŽ²</h1>
        <p class="text-lg">Fun, friends, NFTs!</p>
    </header>

    <main class="w-full max-w-md">
        <div id="mainMenu" class="text-center">
            <div class="mb-4">
                <button id="betButton" class="neon-button py-2 px-4 text-lg">
                    Bet-A-Sketchy
                    <span id="infoButton" class="ml-2 text-sm cursor-pointer">i</span>
                </button>
            </div>
            <button class="neon-button py-2 px-4 text-lg opacity-50 cursor-not-allowed">Stake-A-Milio</button>
        </div>

        <div id="gameInterface" class="hidden p-4 bg-gray-800 rounded-lg shadow-lg">
            <div class="text-center mb-4">
                <button id="connectWallet" class="neon-button py-2 px-4">ðŸ”Œ Connect Wallet</button>
                <p id="accountInfo" class="text-sm mt-2">Account: Not connected</p>
            </div>

            <div class="mb-4">
                <p class="text-sm">Selected NFT: <span id="selectedNFT">Your Sketchy</span></p>
                <button id="selectNFTBtn" class="neon-button py-1 px-2 text-sm mt-1" disabled>ðŸŽ¯ Select NFT</button>
            </div>

            <button id="createGameBtn" class="neon-button py-2 px-4 w-full mb-4" disabled>ðŸŽ° Create Game</button>

            <div class="mb-4">
                <p class="text-sm font-bold">ðŸŽ¯ Open Games</p>
                <ul id="openGamesList" class="mt-2"></ul>
            </div>

            <p id="status" class="text-center text-sm">Status: Waiting...</p>
        </div>
    </main>

    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 class="text-lg font-bold mb-2">About Bet-A-Sketchy</h2>
            <p class="text-sm">50% chance PVP to win a Sketchy by betting one, verified by Gelato. </p>
            <p class="text-sm">
                <a href="#" class="text-orange-500">ABScan</a> | 
                <a href="#" class="text-orange-500">More Info</a>
            </p>
        </div>
    </div>

    <div id="nftModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 class="text-lg font-bold mb-2">Select NFT</h2>
            <div id="nftGrid" class="mt-2 grid grid-cols-3 gap-2"></div>
        </div>
    </div>

    <div id="resultsModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 class="text-lg font-bold mb-2">Game Results</h2>
            <ul id="resultsModalList" class="mt-2"></ul>
        </div>
    </div>

    <div id="videoOverlay" class="hidden flex flex-col items-center justify-center">
        <div id="animationNFTs" class="flex"></div>
        <video id="resultVideo" class="w-64 h-64" autoplay></video>
        <p id="resultText" class="text-lg font-bold mt-2"></p>
    </div>

    <div id="loadingScreen" class="hide flex items-center justify-center">
        <p class="text-lg">Loading SketchyMilios...</p>
    </div>

    <div class="fixed bottom-4 right-4">
        <button id="resultsButton" class="neon-button py-2 px-4 relative hidden">
            Results
            <span id="resultsNotification" class="absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center hidden">0</span>
        </button>
    </div>

    <script>
        const gameABI = [
            "function createGame(uint256 tokenId)",
            "function joinGame(uint256 gameId, uint256 tokenId)",
            "function getOpenGames() view returns (uint256[])",
            "function getGame(uint256 gameId) view returns (tuple(address player1, uint256 tokenId1, address player2, uint256 tokenId2, bool active, uint256 requestId, bytes data, uint256 joinTimestamp, uint256 createTimestamp))",
            "function cancelUnjoinedGame(uint256 gameId)",
            "event GameCreated(uint256 gameId, address player1, uint256 tokenId1)",
            "event GameJoined(uint256 gameId, address player2, uint256 tokenId2)",
            "event RandomnessRequested(uint256 gameId, uint256 requestId)",
            "event GameResolved(uint256 gameId, address winner, uint256 tokenId1, uint256 tokenId2)",
            "event GameCanceled(uint256 gameId)"
        ];

        const nftABI = [
            "function tokensOfOwner(address owner) view returns (uint256[])",
            "function approve(address to, uint256 tokenId)",
            "function tokenURI(uint256 tokenId) view returns (string)"
        ];

        let uiOptions = null;

        let isPlayingResultVideo = false;
        let lastResolvedGames, lastAccount, lastResolveGame;

        function initializeUI({ socket, getAccount, getResolvedGames, getUserTokens, setSelectedTokenId, resolveGame }) {
            uiOptions = { socket, getAccount, getResolvedGames, getUserTokens, setSelectedTokenId, resolveGame };
            
            document.getElementById('infoButton').addEventListener('click', () => {
                console.log('Opening info modal');
                document.getElementById('infoModal').style.display = 'block';
            });

            document.getElementById('betButton').addEventListener('click', () => {
                console.log('Bet-A-Sketchy clicked, showing game interface');
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('gameInterface').classList.remove('hidden');
            });

            document.getElementById('selectNFTBtn').addEventListener('click', () => {
                console.log('Opening NFT selection modal');
                displayNFTsInModal(getUserTokens());
                document.getElementById('nftModal').style.display = 'block';
            });

            document.getElementById('resultsButton').addEventListener('click', (e) => {
                e.stopPropagation();
                console.log('Results button clicked, opening modal');
                updateResultsModal(getResolvedGames(), getAccount(), resolveGame);
                document.getElementById('resultsModal').style.display = 'block';
            });

            document.getElementById('infoModal').querySelector('.close').onclick = () => {
                document.getElementById('infoModal').style.display = 'none';
            };

            document.getElementById('nftModal').querySelector('.close').onclick = () => {
                document.getElementById('nftModal').style.display = 'none';
            };

            document.getElementById('resultsModal').querySelector('.close').onclick = () => {
                console.log('Closing results modal');
                socket.emit('markGamesViewed', { account: getAccount(), gameIds: getResolvedGames().map(g => g.gameId) });
                document.getElementById('resultsModal').style.display = 'none';
            };

            window.onclick = (event) => {
                if (event.target === document.getElementById('infoModal')) {
                    document.getElementById('infoModal').style.display = 'none';
                }
                if (event.target === document.getElementById('nftModal')) {
                    document.getElementById('nftModal').style.display = 'none';
                }
                if (event.target === document.getElementById('resultsModal')) {
                    console.log('Clicked outside results modal');
                    socket.emit('markGamesViewed', { account: getAccount(), gameIds: getResolvedGames().map(g => g.gameId) });
                    document.getElementById('resultsModal').style.display = 'none';
                }
            };
        }

        function showLoadingScreen() {
            console.log('Showing loading screen');
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.classList.remove('hide');
            loadingScreen.classList.add('show');
        }

        function hideLoadingScreen() {
            console.log('Hiding loading screen');
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.classList.remove('show');
            loadingScreen.classList.add('hide');
        }

        function updateStatus(message) {
            console.log('Status update:', message);
            document.getElementById('status').textContent = message;
        }

        function formatTimeRemaining(seconds) {
            if (seconds <= 0) return 'Now';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours > 0 ? hours + 'h ' : ''}${minutes > 0 ? minutes + 'm ' : ''}${secs}s`;
        }

        function displayNFTsInModal(userTokens) {
            console.log('Displaying NFTs in modal, count:', userTokens.length);
            const nftGrid = document.getElementById('nftGrid');
            nftGrid.innerHTML = '';
            if (userTokens.length === 0) {
                nftGrid.innerHTML = '<p class="text-center text-xs">No NFTs available</p>';
                return;
            }
            userTokens.forEach(token => {
                console.log('Creating NFT item for token ID:', token.id);
                const div = document.createElement('div');
                div.className = 'nft-item';
                const img = document.createElement('img');
                img.src = token.image;
                img.alt = `NFT #${token.id}`;
                img.style.pointerEvents = 'none';
                const p = document.createElement('p');
                p.className = 'text-xs';
                p.textContent = `#${token.id}`;
                div.appendChild(img);
                div.appendChild(p);
                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('NFT clicked:', token.id);
                    selectNFT(token.id, token.image);
                });
                nftGrid.appendChild(div);
            });
        }

        function selectNFT(tokenId, image) {
            console.log('Selecting NFT with ID:', tokenId);
            if (uiOptions && uiOptions.setSelectedTokenId) {
                uiOptions.setSelectedTokenId(tokenId);
            } else {
                console.error('setSelectedTokenId is not available');
            }
            document.getElementById('selectedNFT').innerHTML = `<img src="${image}" alt="NFT #${tokenId}" class="w-8 h-8 inline-block mr-1 rounded border border-orange-500"><p class="inline text-xs">NFT #${tokenId}</p>`;
            document.getElementById('nftModal').style.display = 'none';
        }

        function updateOpenGames(games, account) {
            console.log('Updating open games list with:', games);
            const openGamesList = document.getElementById('openGamesList');
            openGamesList.innerHTML = '';
            if (!games || games.length === 0) {
                console.log('No open games to display');
                openGamesList.innerHTML = '<li class="text-center text-xs opacity-70">No open games.</li>';
                return;
            }
            games.forEach(game => {
                console.log('Rendering game:', game.id, 'Player:', game.player1, 'Token:', game.tokenId1);
                const isMine = account && game.player1.toLowerCase() === account.toLowerCase();
                const currentTime = Math.floor(Date.now() / 1000);
                const timeUntilCancel = Number(game.createTimestamp) + 3600 - currentTime;
                const canCancel = isMine && timeUntilCancel <= 0;
                let actionButton = '';
                if (isMine) {
                    actionButton = canCancel 
                        ? `<button class="neon-button py-0.5 px-1 text-xs cancel-game-btn" data-game-id="${game.id}">Cancel</button>`
                        : `<span class="text-xs opacity-70">Cancel in ${formatTimeRemaining(timeUntilCancel)}</span>`;
                } else if (account) {
                    actionButton = `<button class="neon-button py-0.5 px-1 text-xs join-game-btn" data-game-id="${game.id}">Join</button>`;
                } else {
                    actionButton = `<span class="text-xs opacity-70">Connect wallet to join</span>`;
                }
                const li = document.createElement('li');
                li.className = 'game-card p-2 flex justify-between items-center';
                li.innerHTML = `
                    <div class="flex items-center">
                        <img src="${game.image}" alt="NFT #${game.tokenId1}" class="w-8 h-8 mr-2 rounded shadow border border-orange-500">
                        <div>
                            <span class="font-bold text-xs">Game #${game.id}</span><br>
                            <span class="text-xs opacity-70">NFT #${game.tokenId1} | ${game.createdAt}</span>
                        </div>
                    </div>
                    ${actionButton}`;
                openGamesList.appendChild(li);
            });

            document.querySelectorAll('.join-game-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const gameId = button.getAttribute('data-game-id');
                    window.joinGameFromList(gameId);
                });
            });
            document.querySelectorAll('.cancel-game-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const gameId = button.getAttribute('data-game-id');
                    window.cancelUnjoinedFromList(gameId);
                });
            });
        }

        function updateResultsModal(resolvedGames, account, resolveGame) {
            lastResolvedGames = resolvedGames;
            lastAccount = account;
            lastResolveGame = resolveGame;
            console.log('Updating results modal with:', resolvedGames);
            const resultsModalList = document.getElementById('resultsModalList');
            resultsModalList.innerHTML = '';
            const userGames = resolvedGames.filter(game => 
                !game.userResolved[account.toLowerCase()] && 
                (game.player1.toLowerCase() === account.toLowerCase() || 
                 (game.player2 && game.player2.toLowerCase() === account.toLowerCase()))
            );
            const unviewedCount = userGames.filter(game => !game.viewed[account.toLowerCase()]).length;
            if (userGames.length === 0) {
                resultsModalList.innerHTML = '<li class="text-center text-xs opacity-70">No unresolved games.</li>';
                if (!isPlayingResultVideo) {
                    document.getElementById('resultsButton').classList.add('hidden');
                    document.getElementById('resultsNotification').classList.add('hidden');
                }
                return;
            }
            document.getElementById('resultsButton').classList.remove('hidden');
            document.getElementById('resultsNotification').classList.remove('hidden');
            document.getElementById('resultsNotification').textContent = unviewedCount || '0';
            userGames.forEach(game => {
                const isMine = account && (game.player1.toLowerCase() === account.toLowerCase() || 
                                          (game.player2 && game.player2.toLowerCase() === account.toLowerCase()));
                const resolveButton = isMine ? `<button class="neon-button py-0.5 px-1 text-xs resolve-game-btn" data-game-id="${game.gameId}">Resolve</button>` : '';
                const li = document.createElement('li');
                li.className = 'game-card p-2 flex justify-between items-center';
                li.innerHTML = `
                    <div>
                        <div class="font-bold text-xs">Game #${game.gameId}</div>
                        <div class="text-xs">NFT #${game.tokenId1} vs ${game.tokenId2 || 'N/A'}</div>
                    </div>
                    ${resolveButton}`;
                resultsModalList.appendChild(li);
            });

            document.querySelectorAll('.resolve-game-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const gameId = button.getAttribute('data-game-id');
                    resolveGame(gameId);
                });
            });
        }

        function playResultVideo(src, text, image1, image2) {
            console.log('Playing result video:', src, text, 'Images:', image1, image2);
            isPlayingResultVideo = true;
            const video = document.getElementById('resultVideo');
            const overlay = document.getElementById('videoOverlay');
            const resultText = document.getElementById('resultText');
            const animationNFTs = document.getElementById('animationNFTs');

            const validImage1 = image1 && image1 !== 'undefined' ? image1 : 'https://via.placeholder.com/64';
            const validImage2 = image2 && image2 !== 'undefined' ? image2 : 'https://via.placeholder.com/64';

            animationNFTs.innerHTML = `
                <img src="${validImage1}" alt="NFT1" onerror="this.src='https://via.placeholder.com/64';">
                <img src="${validImage2}" alt="NFT2" onerror="this.src='https://via.placeholder.com/64';">
            `;
            video.src = src;
            resultText.textContent = text;

            overlay.classList.remove('hidden', 'fade-out');
            setTimeout(() => {
                overlay.classList.add('fade-in');
            }, 10);

            video.play().catch(error => {
                console.error('Error playing video:', error);
                updateStatus(`Error playing result video: ${error.message}`);
                overlay.classList.remove('fade-in');
                overlay.classList.add('fade-out');
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    overlay.classList.remove('fade-out');
                    animationNFTs.innerHTML = '';
                }, 800);
                isPlayingResultVideo = false;
                if (lastResolvedGames && lastAccount && lastResolveGame) {
                    updateResultsModal(lastResolvedGames, lastAccount, lastResolveGame);
                }
            });

            video.onended = () => {
                console.log('Video ended, hiding overlay');
                overlay.classList.remove('fade-in');
                overlay.classList.add('fade-out');
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    overlay.classList.remove('fade-out');
                    animationNFTs.innerHTML = '';
                }, 800);
                isPlayingResultVideo = false;
                if (lastResolvedGames && lastAccount && lastResolveGame) {
                    updateResultsModal(lastResolvedGames, lastAccount, lastResolveGame);
                }
            };
        }

        const gameAddress = '0xf6b8d2E0d36669Ed82059713BDc6ACfABe11Fde6';
        const nftAddress = '0x08533a2b16e3db03eebd5b23210122f97dfcb97d';
        const socket = io('https://sketchyflipback.onrender.com', {
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });

        let provider, signer, account, gameContract, gameContractWithSigner, nftContract;
        let selectedTokenId = null;
        let userTokens = [];
        let resolvedGames = [];
        let isResolving = false;

        function resolveGame(gameId) {
            if (isResolving) {
                console.log('Resolve already in progress, ignoring click for game:', gameId);
                return;
            }
            isResolving = true;
            console.log('Resolving game:', gameId, 'for account:', account);
            updateStatus('Loading... Checking game resolution...');
            socket.emit('resolveGame', { gameId, account });
            setTimeout(() => {
                if (isResolving) {
                    isResolving = false;
                    updateStatus('Resolution timed out, please try again.');
                    socket.emit('fetchResolvedGames', { account });
                }
            }, 30000);
        }

        initializeUI({ 
            socket, 
            getAccount: () => account, 
            getResolvedGames: () => resolvedGames, 
            getUserTokens: () => userTokens, 
            setSelectedTokenId: (id) => { selectedTokenId = id; },
            resolveGame
        });

        document.getElementById('connectWallet').addEventListener('click', async () => {
            if (!window.ethereum) {
                updateStatus('Install MetaMask.');
                return;
            }
            try {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send("eth_requestAccounts", []);
                signer = provider.getSigner();
                account = await signer.getAddress();
                document.getElementById('accountInfo').textContent = `Account: ${account.slice(0,6)}...${account.slice(-4)}`;
                updateStatus('Wallet connected...');
                
                gameContract = new ethers.Contract(gameAddress, gameABI, provider);
                gameContractWithSigner = gameContract.connect(signer);
                nftContract = new ethers.Contract(nftAddress, nftABI, signer);
                
                socket.emit('registerAddress', { address: account });
                await fetchUserTokens(true);
                updateStatus('Connected! Fetching games...');
                socket.emit('fetchResolvedGames', { account });
            } catch (error) {
                console.error('Error connecting wallet:', error);
                updateStatus(`Connection error: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        });

        document.getElementById('createGameBtn').addEventListener('click', async () => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            if (!selectedTokenId) return updateStatus('Select an NFT to bet.');
            try {
                updateStatus('Approving NFT...');
                const approveTx = await nftContract.approve(gameAddress, selectedTokenId);
                await approveTx.wait();
                updateStatus('Creating game...');
                const tx = await gameContractWithSigner.createGame(selectedTokenId);
                await tx.wait();
                updateStatus('Game created! Waiting for join...');
                await fetchUserTokens();
                selectedTokenId = null;
                document.getElementById('selectedNFT').innerHTML = 'Your Sketchy';
            } catch (error) {
                console.error('Error creating game:', error);
                updateStatus(`Error creating game: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        });

        window.joinGameFromList = async (gameId) => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            if (!selectedTokenId) return updateStatus('Select an NFT to bet.');
            try {
                updateStatus('Approving NFT...');
                const approveTx = await nftContract.approve(gameAddress, selectedTokenId);
                await approveTx.wait();
                updateStatus('Joining game...');
                const tx = await gameContractWithSigner.joinGame(gameId, selectedTokenId);
                await tx.wait();
                updateStatus('Joined! Waiting for result...');
                await fetchUserTokens();
                selectedTokenId = null;
                document.getElementById('selectedNFT').innerHTML = 'Your Sketchy';
            } catch (error) {
                console.error('Error joining game:', error);
                updateStatus(`Error joining: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        };

        window.cancelUnjoinedFromList = async (gameId) => {
            if (!gameContractWithSigner) return updateStatus('Connect wallet first.');
            try {
                updateStatus('Canceling game...');
                const tx = await gameContractWithSigner.cancelUnjoinedGame(gameId);
                await tx.wait();
                updateStatus('Game canceled.');
                await fetchUserTokens();
            } catch (error) {
                console.error('Error canceling unjoined game:', error);
                updateStatus(`Error canceling: ${error.message}`);
                if (error.code === -32603) {
                    updateStatus('RPC Error: Disconnect MetaMask from the website and reconnect.');
                }
            }
        };

        async function fetchUserTokens(showLoading = false) {
            if (!nftContract || !account) {
                console.log('Cannot fetch tokens: nftContract or account missing');
                return;
            }
            if (showLoading) showLoadingScreen();
            userTokens = [];
            const nftGrid = document.getElementById('nftGrid');
            nftGrid.innerHTML = '<p class="text-center text-xs">Loading NFTs...</p>';
            try {
                console.log('Fetching tokens for account:', account);
                const tokens = await nftContract.tokensOfOwner(account);
                console.log('Tokens fetched:', tokens);
                for (let id of tokens) {
                    let uri = await nftContract.tokenURI(id);
                    if (uri.startsWith('ipfs://')) uri = 'https://ipfs.io/ipfs/' + uri.slice(7);
                    const response = await fetch(uri);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const metadata = await response.json();
                    let image = metadata.image;
                    if (image && image.startsWith('ipfs://')) image = 'https://ipfs.io/ipfs/' + image.slice(7);
                    userTokens.push({ id: id.toString(), image: image || 'https://via.placeholder.com/64' });
                }
                console.log('User tokens loaded:', userTokens);
                document.getElementById('selectNFTBtn').disabled = userTokens.length === 0;
                document.getElementById('createGameBtn').disabled = userTokens.length === 0;
                if (userTokens.length === 0) {
                    nftGrid.innerHTML = '<p class="text-center text-xs">No NFTs owned</p>';
                } else {
                    displayNFTsInModal(userTokens);
                }
                if (showLoading) hideLoadingScreen();
            } catch (error) {
                console.error('Error fetching tokens:', error);
                updateStatus(`Tokens fetch error: ${error.message}`);
                nftGrid.innerHTML = '<p class="text-center text-red-500 text-xs">Error loading NFTs</p>';
                if (showLoading) hideLoadingScreen();
            }
        }

        socket.on('connect', () => {
            console.log('Connected to backend:', socket.id);
            if (account) {
                socket.emit('registerAddress', { address: account });
            }
            updateStatus('Connected to backend, waiting for games...');
        });

        socket.on('openGamesUpdate', (games) => {
            console.log('Received openGamesUpdate:', games);
            updateOpenGames(games, account);
        });

        socket.on('gameJoined', async (data) => {
            console.log('Received gameJoined:', data);
            resolvedGames.push({ 
                gameId: data.gameId, 
                player1: data.player1, 
                tokenId1: data.tokenId1, 
                image1: data.image1,
                player2: data.player2, 
                tokenId2: data.tokenId2, 
                image2: data.image2,
                resolved: false, 
                userResolved: { [account.toLowerCase()]: false }, 
                viewed: { [account.toLowerCase()]: false }
            });
            updateResultsModal(resolvedGames, account);
            updateStatus(`Game #${data.gameId} joined by ${data.player2.slice(0, 6)}...${data.player2.slice(-4)}`);
            await fetchUserTokens();
        });

        socket.on('resolvedGames', (games) => {
            console.log('Received resolvedGames:', games);
            resolvedGames = games.map(game => ({
                ...game,
                userResolved: game.userResolved || { [account.toLowerCase()]: false },
                viewed: game.viewed || { [account.toLowerCase()]: false }
            }));
            updateResultsModal(resolvedGames, account);
        });

        socket.on('gameResolution', async (data) => {
            console.log('Received gameResolution:', data);
            if (data.error) {
                if (data.error === 'Game not resolved or no winner') {
                    console.log(`Game ${data.gameId} not yet resolved, retrying...`);
                    setTimeout(() => {
                        socket.emit('fetchResolvedGames', { account });
                    }, 3000); 
                    return; 
                }
                updateStatus(`Error resolving game #${data.gameId}: ${data.error}`);
                isResolving = false;
                return;
            }
            isResolving = false;
            const win = account && data.winner && data.winner.toLowerCase() === account.toLowerCase();
            updateStatus(`Game #${data.gameId} resolved: ${win ? 'You Win!' : 'You Lose!'}`);
            playResultVideo(
                win ? '/win.mp4' : '/lose.mp4', 
                win ? 'You Win!' : 'You Lose!', 
                data.image1 || 'https://via.placeholder.com/64', 
                data.image2 || 'https://via.placeholder.com/64'
            );
            socket.emit('fetchResolvedGames', { account });
            await fetchUserTokens();
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from backend');
            updateStatus('Disconnected from backend, attempting reconnect...');
        });

        socket.on('connect_error', (error) => {
            console.error('Socket connection error:', error);
            updateStatus(`Socket connection error: ${error.message}`);
        });

        socket.on('reconnect', (attempt) => {
            console.log('Reconnected to backend after attempt:', attempt);
            if (account) {
                socket.emit('registerAddress', { address: account });
            }
            updateStatus('Reconnected to backend!');
        });

        socket.on('reconnect_error', (error) => {
            console.error('Socket reconnection error:', error);
            updateStatus(`Socket reconnection error: ${error.message}`);
        });
    </script>
</body>
</html>